---
title: 브라우저의 동작원리, 브라우저는 어떻게 동작할까?(작성중)
publishedAt: '2023-12-19'
summary: 브라우저의 동작원리를 아주 자세하게 정리해봅시다!
category: Dev
---

<p align='center'>
  <img src='/blog/img/browers.png' width='auto' alt='browers' />
</p>

## 개요

프론트엔드 면접에서 대표 질문 중 하나는, 브라워저의 동작원리 혹은 렌더링 방식과 순서의 관한 질문입니다.<br/>
면접용으로 단순 암기가 아닌 흐름과 순서를 깊게 학습하고 정리합니다.

## 브라우저의 구조

<p align='center'>
  <img src='/blog/img/browers.png' width='auto' alt='browers' />
</p>

- 사용자 인터페이스

  - 뒤로가기, 앞으로가기, 새로고침 등등 웹페이지 상단바

- 브라우저 엔진

  - 사용자 인터페이스와 렌더링 엔진 사이에 동작을 제어, ex) 뒤로가기 버튼을 클릭 시 뒤로가기를 인식해서 렌더링 엔진에 알려주는 역할

- 렌더링 엔진

  - 웹사이트를 그리는 엔진, 사용자 인터페이스 외 아래 부분으로 우리가 보는 웹사이트 화면

- 통신

  - HTTP 요청과 같은 네트워크 호출에 사용 (개발자 도구에서 `Network` 탭에서 활동을 확인 가능)

- 자바스크립트 해석기

  - 자바스크립트를 이해하는 역할, ex) 크롬에서는 V8엔진 사용

- UI 백엔드

  - 사용자와 소통하는 부분, ex) 마우스 이벤트, 사용자 입력, 클릭 등을 핸들링 하는 곳

- 자료 저장소

  - 브라우저에서 자료를 저장하는 계층, ex) 로컬스토리지, 세션스토리지, 쿠키

## 주소창에 naver.com을 입력하면 어떤일이 벌어질까? DNS란?

주소창에 naver.com을 입력하면 브라우저가 naver.com을 인식하게 됩니다.
하지만 naver.com 자체를 인식하는게 아닙니다. naver.com은 인간이 보기 편하게 부여한 이름입니다.
브라우저가 이해하는 것은 IP주소이기 때문에 컴퓨터가 naver.com의 IP주소를 찾아야하고, DNS(Domain Name System)라는 서비스에 찾아갑니다.

<p align='center'>
  <img src='/blog/img/dns.png' width='auto' alt='dns' />
</p>

DNS는 사전처럼 naver.com의 IP 주소는 192.10.6.3 / google.com의 IP 주소는 192.5.30.3 이런식으로 이름과 IP 주소가 정리되어 있으며,
DNS가 naver.com에 해당하는 IP 주소를 전달해주고, IP 주소를 받으면 그때서야 주소를 찾아갑니다.

사실 위의 설명처럼 해당하는 IP주소를 찾는게 단순하지 않습니다. 세상에 정말 많은 웹사이트와 IP 주소가 있기 때문입니다.
힘들게 알게된 주소는 굉장히 어렵게 알게된 만큼, `DNS cache`에 저장한 후 다음에는 여기서 바로 가져옵니다.

이러한 과정을 통해 IP주소를 얻게 됩니다.

## 캐릭터화(리소스 요청)

브라우저는 IP주소를 얻은 후 웹서버에 IP주소를 가지고 html을 요청하게 됩니다.<br/>
처음 받은 html의 형태는 우리가 아는 모습이 아닌, 바이트 데이터 스트림(메트릭스 영화처럼 0101...모습)으로 받게 됩니다.
브라우저는 바이트 데이터를 읽을 수 있도록 **인코딩**을 하게 됩니다. 인코딩 방법은 **UTF-8** 인코딩을 사용해 해석합니다.
`<meta charset="UTF-8" />` 코드는 뭘로 인코딩이 됫는지 멘션해주기 위해서 항상 적용시키는 겁니다.

```tsx {4}
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>My simple page</title>
    <link rel="stylesheet" src="styles.css" />
    <script src="myscript.js"></script>
  </head>
  <body>
    ...
  </body>
</html>
```

## 토큰화

바이트를 캐릭터화 시킨 후 드디어 알아볼 수 있는 Document(문서)가 생겼고 읽을 수 있는 캐릭터들이 있습니다.
하지만 브라우저가 바로 이해할 수 있는 것은 아닙니다. 브라우저 이 문서를 하나하나 다시 읽어야 합니다.
이 과정을 **Tokenizer(토큰화)** 라고 합니다.

말그대로 글자 하나씩 읽는 과정입니다. 예를들면 `<html><body><div>...` 코드가 있다면, `<` `h` `m` `l` `>` 순서로 읽게 되며
태그가 열리고 닫히는 것을 인지하고 태그가 닫히면, **Start Tag Token**이 **html** 이라는 토큰을 만들게 됩니다.

<p align='center'>
  <img src='/blog/img/html-parser.png' width='auto' alt='html-parser' />
</p>

## Nodes(노드)

토큰화 과정이 끝나면, 토큰을 의미있는 단위로 재해석을 해야합니다. 의미있는 값으로 만들어야 하며, **Object 형태**로 만들게 됩니다.

예를들면, **Start Tag Token div**와 **End Tag Token div**가 있다면, div 태그가 있구나라고 인지하고 이를 Object화 시킵니다.
아래의 코드와 같이 div태그가 있다면 div태그가 있고 속성은 어쩌고 저쩌고, button태그가 있다면 button태그가 있고 속성은 어쩌고 하면서
객체화를 시킵니다. 이를 **Nodes(노드)** 라고 합니다.

정리하자면, 토큰화는 1차적으로 떠듬떠듬 읽어놓고, 이를 가지고 의미있는 태그가 뭐가 있는지 의미있는 형태로 구조화하게 되는데 그게 Nodes(노드)입니다.

```
{
  tag: div
  attribute:
  ...
}

{
  tag: button
  attribute:
  ...
}
```

## DOM tree

노드가 생성된 후 부모와 자식관계가 있는 html 태그와 같이 노드들의 관계를 부여해줘야 하는데, 이를 **Model** 이라고 합니다.
이를 전부 합친것이 DOM(Document Object Model)이라고 하며, **DOM tree** 가 만들게 됩니다.

## CSSOM tree

---

## 참고

- [DOM과 CSSOM, 렌더링 과정](https://www.youtube.com/watch?v=Mqh13dNI8jc)
- [](https://yozm.wishket.com/magazine/detail/1338/)
- [브라우저의 작동 원리](https://blog.haeyum.me/cs/web/frontend/Browser/)
