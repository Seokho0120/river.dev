---
title: 브라우저의 동작원리, 브라우저는 어떻게 동작할까?
publishedAt: '2023-12-19'
summary: 브라우저의 동작원리를 아주 자세하게 정리했습니다.
category: Dev
---

<p align='center'>
  <img src='/blog/img/CRP.png' width='auto' alt='CRP' />
</p>

## 개요

프론트엔드 면접에서 대표 질문 중 하나는, 브라워저의 동작원리 혹은 렌더링 방식과 순서의 관한 질문입니다.<br/>
면접 대비로 단순 암기가 아닌, 흐름을 이해하고 학습한 내용을 정리합니다.

## TL;DR

본 글의 내용은 크게 4개의 순서로 요약할 수 있습니다.

- HTML으로부터 DOM 트리, CSS로부터 CSSOM 트리를 빌드 합니다.
- DOM 트리와 CSSOM 트리 결합하여 렌더 트리를 형성합니다.
- 렌더트리에서 레이아웃 프로세스가 진행되며, 각 노드의 위치와 형태를 계산합니다.
- 계산된 노드를 화면에 페인트 합니다.

## 브라우저의 구조

<p align='center'>
  <img src='/blog/img/browers.png' width='auto' alt='browers' />
</p>

- 사용자 인터페이스

  - 뒤로가기, 앞으로가기, 새로고침 등등 웹페이지 상단바

- 브라우저 엔진

  - 사용자 인터페이스와 렌더링 엔진 사이에 동작을 제어, ex) 뒤로가기 버튼을 클릭 시 뒤로가기를 인식해서 렌더링 엔진에 알려주는 역할

- 렌더링 엔진

  - 웹사이트를 그리는 엔진, 사용자 인터페이스 외 아래 부분으로 우리가 보는 웹사이트 화면

- 통신

  - HTTP 요청과 같은 네트워크 호출에 사용 (개발자 도구에서 `Network` 탭에서 활동을 확인 가능)

- 자바스크립트 해석기

  - 자바스크립트를 이해하는 역할, ex) 크롬에서는 V8엔진 사용

- UI 백엔드

  - 사용자와 소통하는 부분, ex) 마우스 이벤트, 사용자 입력, 클릭 등을 핸들링 하는 곳

- 자료 저장소

  - 브라우저에서 자료를 저장하는 계층, ex) 로컬스토리지, 세션스토리지, 쿠키

## 주소창에 naver.com을 입력하면 어떤일이 벌어질까? DNS란?

주소창에 naver.com을 입력하면 브라우저가 naver.com을 인식하게 됩니다.
하지만 naver.com 자체를 인식하는게 아닙니다. naver.com은 인간이 보기 편하게 부여한 이름입니다.
브라우저가 이해하는 것은 IP주소이기 때문에 컴퓨터가 naver.com의 IP주소를 찾아야하고, DNS(Domain Name System)라는 서비스에 찾아갑니다.

<p align='center'>
  <img src='/blog/img/dns.png' width='auto' alt='dns' />
</p>

DNS는 사전처럼 naver.com의 IP 주소는 192.10.6.3 / google.com의 IP 주소는 192.5.30.3 이런식으로 이름과 IP 주소가 정리되어 있으며,
DNS가 naver.com에 해당하는 IP 주소를 전달해주고, IP 주소를 받으면 그때서야 주소를 찾아갑니다.

사실 위의 설명처럼 해당하는 IP주소를 찾는게 단순하지 않습니다. 세상에 정말 많은 웹사이트와 IP 주소가 있기 때문입니다.
힘들게 알게된 주소는 굉장히 어렵게 알게된 만큼, `DNS cache`에 저장한 후 다음에는 여기서 바로 가져옵니다.

이러한 과정을 통해 IP주소를 얻게 됩니다.

## 캐릭터화(리소스 요청)

브라우저는 IP주소를 얻은 후 웹서버에 IP주소를 가지고 html을 요청하게 됩니다.<br/>
처음 받은 html의 형태는 우리가 아는 모습이 아닌, 바이트 데이터 스트림(메트릭스 영화처럼 0101...모습)으로 받게 됩니다.
브라우저는 바이트 데이터를 읽을 수 있도록 **인코딩**을 하게 됩니다. 인코딩 방법은 **UTF-8** 인코딩을 사용해 해석합니다.
`<meta charset="UTF-8" />` 코드는 뭘로 인코딩이 됫는지 멘션해주기 위해서 항상 적용시키는 겁니다.

```tsx {4}
<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>My simple page</title>
    <link rel="stylesheet" src="styles.css" />
    <script src="myscript.js"></script>
  </head>
  <body>
    ...
  </body>
</html>
```

## 토큰화

바이트를 캐릭터화 시킨 후 드디어 알아볼 수 있는 Document(문서)가 생겼고 읽을 수 있는 캐릭터들이 있습니다.
하지만 브라우저가 바로 이해할 수 있는 것은 아닙니다. 브라우저 이 문서를 하나하나 다시 읽어야 합니다.
이 과정을 **Tokenizer(토큰화)** 라고 합니다.

말그대로 글자 하나씩 읽는 과정입니다. 예를들면 `<html><body><div>...` 코드가 있다면, `<` `h` `m` `l` `>` 순서로 읽게 되며
태그가 열리고 닫히는 것을 인지하고 태그가 닫히면, **Start Tag Token**이 **html** 이라는 토큰을 만들게 됩니다.

<p align='center'>
  <img src='/blog/img/html-parser.png' width='auto' alt='html-parser' />
</p>

## Nodes(노드)

토큰화 과정이 끝나면, 토큰을 의미있는 단위로 재해석을 해야합니다. 의미있는 값으로 만들어야 하며, **Object 형태**로 만들게 됩니다.

예를들면, **Start Tag Token div**와 **End Tag Token div**가 있다면, div 태그가 있구나라고 인지하고 이를 Object화 시킵니다.
아래의 코드와 같이 div태그가 있다면 div태그가 있고 속성은 어쩌고 저쩌고, button태그가 있다면 button태그가 있고 속성은 어쩌고 하면서
객체화를 시킵니다. 이를 **Nodes(노드)** 라고 합니다.

정리하자면, 토큰화는 1차적으로 떠듬떠듬 읽어놓고, 이를 가지고 의미있는 태그가 뭐가 있는지 의미있는 형태로 구조화하게 되는데 그게 Nodes(노드)입니다.

```
{
  tag: div
  attribute:
  ...
}

{
  tag: button
  attribute:
  ...
}
```

## DOM tree

노드가 생성된 후 부모와 자식관계가 있는 html 태그와 같이 노드들의 관계를 부여해줘야 하는데, 이를 **Model** 이라고 합니다.
이를 전부 합친것이 DOM(Document Object Model)이라고 하며, **DOM tree** 가 만들게 됩니다.

## CSSOM tree

코드를 맨위에서부터 읽는 도중에 CSS를 링크하는 코드`<link rel="stylesheet" href="styles.css">`가
HTML 코드내에 삽입되어 있기 때문에, HTML을 파싱하는 도중에 CSS 파싱이 시작됩니다.

순서는 html과 동일하게 **바이트 스트림 → 캐릭터화 → 토큰화 → 노드 → CSSOM(CSS Object Model) Tree** 순서로 진행되며,
마지막에 **CSSOM Tree**를 생성합니다.

<p align='center'>
  <img src='/blog/img/cssom.png' width='auto' alt='CSSOM' />
</p>

### CSS Link 태그가 항상 위에 있는 이유

CSS는 DOM의 생성을 막지 않습니다. DOM이 완성됫다고 바로 웹사이트가 보이지 않습니다. DOM은 항상 CSSOM을 기다립니다.
그렇기 때문에 CSSOM을 최대한 빨리 생성하는게 중요합니다. CSSOM은 웹사이트의 성능에 중요한 역할을 하며, CSS 파일이 너무 크면 DOM은 계속
CSSOM을 기다리게 되기 때문에 현재 페이지에서 필요한 CSS를 구분하여 만드는게 중요합니다. ex) media-query

## Javascript

CSS와 동일하게 읽는 도중 `<script src="main.js">` 코드가 HTML 코드내에 작성되어 있다면, DOM 생성을 중지하고
JS 엔진에 권한을 넘기게 됩니다. JS가 끝나면 HTML 파서로 권한을 넘기고, 중지되었던 시점부터 DOM 생성을 진행하게 됩니다.

따라서 script 태그의 위치에 따라서 DOM 생성이 지연될 수 있기 때문에 일반적으로 body의 끝부분에 script 태그를 넣어주는 것이 좋습니다.
혹은 script 태그의 속성인 `defer`와 `async` 옵션을 사용해 DOM의 생성을 막지 않는 방법도 있습니다.

## Render Tree

브라우저는 DOM tree와 CSSOM tree를 합쳐 **Render Tree**를 생성합니다.
진짜로 웹사이트를 그리기 위한 최종 설계도라고 이해하면 됩니다. <br/>

이때 화면에 그려지지 않는 요소들(쓸데없는 노드들), 예를들면 `<head>`와 `<meta>` 같은 태그들과
`<display: none>` 스타일이 적용된 엘리먼트들은 시각적으로 나타낼 것이 없기 때문에
렌더트리에 그려지지 않습니다.

<p align='center'>
  <img src='/blog/img/render-tree.png' width='auto' alt='render-tree' />
</p>

## 중간 정리!

HTML을 DOM트리로 CSS를 CCSOM으로 생성하고, JS도 불러온 후 Render Tree를 생성합니다. 이제 그리기만 하면 됩니다!

<p align='center'>
  <img src='/blog/img/CRP.png' width='auto' alt='CRP' />
</p>

## Layout

완벽한 설계도가 있다고 해도 바로 그릴 수 없습니다. 노드들이 가지고 있는 속성과 스타일에 따라서 브라우저에 노드들을 어떤 크기로 어떤 위치에
그릴지 계산합니다.

만약 반응형 웹사이트를 개발할때 `%`를 사용하는데, `50%`를 적용한다고 했을때 모바일 버전과 테블릿 버전, 즉 화면 사이즈에 따라서
사이즈가 달라집니다. 이를 정확한 px 값을 계산하는 단계를 **Layout** 이라고 합니다.

## Paint

실제로 그리는 단계입니다.
다만 한페이지에 전부 그리는게 아니라, 여러개의 레이어로 나눠서 그리게 됩니다. 이유는 수정사항이 생겼을때, 한페이지에 전부 그리면
전부 새로 그려야하기 때문에 효율적으로 레이어를 나눠 수정사항만 부분적으로 수정하기 위해서 여러개의 레이어로 나눠서 그리게 됩니다.
ex) photoshop의 layer개념과 비슷합니다.

## Reflow 될때

- 페이지 초기 렌더링 시 (최초 Layout 과정)
- 윈도우 리사이징 시 (Viewport 크기 변경 시)
- 노드 추가 또는 제거
- 요소의 위치, 크기 변경 (left, top, margin, padding, border, width, height 등)
- 폰트 변경(텍스트 내용)과 이미지 크기 변경(크기가 다른 이미지로 변경 시)

## 웹사이트 성능을 좋게 하려면?

- 소스의 사이즈 줄이기(바이트 수 줄이기)
- 외부에서 가져오는 리소스양 줄이기(media 쿼리, 불필요한 파일 나중에)
- 외부에서 가져오는 횟수 줄이기(인라인)
- Reflow, Repaint 줄이기
  - position의 left, right은 Reflow부터 시작하기 때문에, transform을 사용하는게 좋습니다.
  - 애니메이션을 구현 시 미세한 1px씩 보단 3px씩 구현하는게 좋습니다.

## Virtual DOM(가상돔)

브라우저의 동작 과정과 원리를 바탕으로 **가상돔과 리액트의 출현 배경**에 대해 정리할 수 있습니다.<br/>
일반적으로 중요 렌더링 경로는 초당 60회 정도의 주기로 계산을 수행합니다. 이 과정에서 가장 비용이 많이 드는 단계가
레이아웃 단계와 페인트 단계입니다. 그렇기에 성능 최적화를 위해서 두 단계의 연산을 최적화하는 것이 중요합니다.

Javascript를 이용해 DOM을 직접 조작하면, 변경 사항이 있을때마다 레이아웃과 페인트 단계를 초래하게 됩니다.
만약 10개의 DOM 노드를 for문으로 일일이 수정한다면, 하나의 노드에 수정 사항이 생길때마다 화면을 다시 그리는 과정을 거쳐야 할 수 있습니다.
10개를 한번에 수정하는게 아니라, 하나씩 수정된 노드가 10번 다시 화면에 그려질 수 있기 때문에, 일반적으로 **DOM을 직접 조작하는 것은 비효율적**이라고 합니다.

가상돔은 실제로 렌더링되지 않지만, **실제 DOM 구조를 반영한 상태로 메모리에 있는 가상의 DOM**입니다.<br/>
메모리 상에 있고 실제 화면에 그려요~ 할 필요가 없기 때문에, 실제 DOM보다는 연산 비용이 적습니다. 가성돔은 이러한 특징을 바탕으로
변경 사항을 한번에 묶어서 실제DOM에 적용을 합니다. 레이아웃과 페인트 단계에서 한번에 변경되어야할 사항은 많지만, 단 한번의 계산으로
바뀐 DOM을 반영할 수 있기 때문에 연산 횟수는 최소한이 됩니다.

정리하자면, jQuery처럼 DOM을 직접 변경할 경우 DOM 전체를 렌더링해야하고, 이는 곧 **성능저하로 직결**됩니다.
**React**는 렌더링할때 가상DOM을 만들어 유지하며, 화면이 변화할때 가상DOM에서 미리 계산하고 **실제 DOM에서는 한번만 렌더링**을하여
최적화를 제공합니다.

---

## 참고

- [DOM과 CSSOM, 렌더링 과정](https://www.youtube.com/watch?v=Mqh13dNI8jc)
- [브라우저의 작동 원리](https://blog.haeyum.me/cs/web/frontend/Browser/)
- [프론트엔드 개발자라면 알고 있어야 할 브라우저의 동작 과정](https://yozm.wishket.com/magazine/detail/1338/)
